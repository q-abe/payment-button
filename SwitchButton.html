<script>
    const TARGET_OF_PARENT_QUERY = ".form.aem-GridColumn--tablet--10.aem-GridColumn--phone--none.aem-GridColumn--tablet--none.aem-GridColumn--phone--10.aem-GridColumn.aem-GridColumn--offset--phone--1.aem-GridColumn--default--5.aem-GridColumn--offset--tablet--1 bat-form-cashondeliverypayment";

    const CREDIT_RADIO_QUERY = ".bat-form-field.bat-form--cashondelivery-payment-credit-card-header input[name='creditCardHeader']";
    const CASH_RADIO_QUERY = ".cashondelivery-method-section input[name='creditCardHeader']";
    const CREDIT_BUTTON_QUERY = ".bat-form-field.bat-form--cashondelivery-payment-submit button[class='bat-cta-style button-secondary-dark']";
    const CASH_BUTTON_QUERY = ".confirm-order-button-block a[class='bat-cta-style button-secondary-dark center disabled']";

    const COPY_BUTTON_NODE = `<div><button class="copiedPaymentButton disabled" id="initialButton">初期値ボタン</button></div><div><button class="copiedPaymentButton disabled hidden" id="copiedCredit">クレジット決済</button></div><div><button class="copiedPaymentButton disabled hidden" id="copiedCash">代引き決済</button></div>`;
    const ADD_BTN_JUST_BEFORE_QUERY = "#cashondeliveryForm";

    const HIDDEN_CLASS = "hidden";
    const DISABLED_CLASS = "disabled";
    const CHANGE = "change";
    const CLICK = "click";
    const AFTER_END = "afterend";
    const ADD = "add";
    const REMOVE = "remove";

    const copiedCreditQuery = "#copiedCredit";
    const copiedCashQuery = "#copiedCash";
    const initialButtonQuery = "#initialButton";

    /**
     *対象のNodeに変化が起きたらcallback関数を実行する。
     */
    const setChangeAction = (node, callback) => {
        node.addEventListener(CHANGE, callback);
    };

    /**
     *受け取ったプロパティによってHiddenを追加、削除する。
     */
    const setHiddenClass = (node, property) => {
        const isAdd = property === ADD;
        isAdd ? node.classList.add(HIDDEN_CLASS)
            : node.classList.remove(HIDDEN_CLASS);
    };

    /**
     *受け取った追加や削除したい対象の配列を取り出す。
     */
    const toggleHiddenClasses = ({addNodes, removeNodes}) => {
        addNodes.forEach(addNode => {
            setHiddenClass(addNode, ADD);
        });
        removeNodes.forEach(removeNode => {
            setHiddenClass(removeNode, REMOVE);
        });
    };

    /**
     *Radioの切り替えに応じて表示ボタンを真似する。
     */
    const imitateRadioAction = (targetNode, {displayNodes, hideNodes}) => {
        const changedKeysName = {
            addNodes: displayNodes,
            removeNodes: hideNodes
        };
        setChangeAction(targetNode, () => {
            toggleHiddenClasses(changedKeysName);
        });
    };

    /**
     *クリックイベントによるcallback関数の実行。
     */
    const SynchronizationEvent = (node, callback) => {
        node.addEventListener(CLICK, callback);
    };

    /**
     *オリジナルボタンのクリック。
     */
    const copiedClickEvent = (origin) => {
        const clickEvent = new Event(CLICK);
        origin.click();
    };

    /**
     *イベントリスナーの呼び出し。
     */
    const syncClickEvent = (copied, origin) => {
        SynchronizationEvent(copied, () => {
            copiedClickEvent(origin);
        });
    };

    /**
     * 判定次第でdisableの切り替え。
     */
    const syncStateButton = (isDisabled, copiedNode) => {
        isDisabled ? copiedNode.classList.add(DISABLED_CLASS)
            : copiedNode.classList.remove(DISABLED_CLASS);
    };

    /**
     * 条件一致の判定。(いずれかがtrue)
     */
    const checkToDisabled = (node) => {
        const isDisabled = [node.target.getAttribute(DISABLED_CLASS) !== null, node.target.classList.contains(DISABLED_CLASS)];
        return isDisabled.some(isDisabled => isDisabled);
    };


    /**
     * 条件一致の判定。(いずれかがtrue)
     */
    const copiedSyncToOrigin = (targetNode, copiedNode) => {
        const nodeObserver = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                const isDisabled = checkToDisabled(mutation);
                syncStateButton(isDisabled, copiedNode);
            });
        });
        nodeObserver.observe(targetNode, {
            attributes: true
        });
    };

    const startObserveDomRendered = () => {
        const hasNode = {
            creditRadio: undefined,
            creditButton: undefined,
            cashRadio: undefined,
            cashButton: undefined
        };
        const queries = {
            creditRadio: CREDIT_RADIO_QUERY,
            creditButton: CREDIT_BUTTON_QUERY,
            cashRadio: CASH_RADIO_QUERY,
            cashButton: CASH_BUTTON_QUERY
        };

        /**
         * 対象のNodeが存在すればオブジェクトを更新。
         */
        const checkNodesRendered = (node) => {
            Object.keys(queries).forEach(queryKey => {
                if (node.target.querySelector(queries[queryKey])) {
                    hasNode[queryKey] = node.target.querySelector(queries[queryKey]);
                    console.log(`${queryKey}Node rendered`);
                }
            });
        };

        /**
         * 全ての対象Nodeが取得できたか判定。
         */
        const hasAllNodes = () => {
            if (Object.values(hasNode).every(count => count)) {
                targetOfParentObserver.disconnect();
                console.log("targetOfParentObserver disconnected");
                console.log("all targets rendered");
                addElementsFn(ADD_BTN_JUST_BEFORE_QUERY, AFTER_END, COPY_BUTTON_NODE);
                afterLoadingFn(hasNode);
            }
        };

        /**
         * 対象の親Nodeの監視。
         */
        const targetOfParentObserver = new MutationObserver(mutations => {
            mutations.forEach(mutation => {
                checkNodesRendered(mutation);
            });
            hasAllNodes();
        });
        const targetOfParent = document.querySelector(TARGET_OF_PARENT_QUERY);
        targetOfParentObserver.observe(targetOfParent, {
            childList: true,
            subtree: true
        });
    };

    /**
     * Elementの追加。
     */
    const addElementsFn = (query, position, element) => {
        const addTarget = document.querySelector(query);
        addTarget.insertAdjacentHTML(position, element);
        console.log(`Element is added at the ${position}`);
    };

    const afterLoadingFn = (hasNodes) => {
        const copiedCredit = document.querySelector(copiedCreditQuery);
        const copiedCash = document.querySelector(copiedCashQuery);
        const initialButton = document.querySelector(initialButtonQuery);

        if (copiedCredit && copiedCash && initialButton) {
            /**
             *支払いを選択したとき、非選択の購入確定ボタンを非表示にする
             */
            imitateRadioAction(hasNodes.creditRadio, {
                    displayNodes: [copiedCash, initialButton],
                    hideNodes: [copiedCredit]
                }
            );
            imitateRadioAction(hasNodes.cashRadio, {
                    displayNodes: [copiedCredit, initialButton],
                    hideNodes: [copiedCash]
                }
            );

            /**
             * コピーボタンをクリックしたときにオリジナルのボタンをクリックする。
             */
            syncClickEvent(copiedCredit, hasNodes.creditButton);
            syncClickEvent(copiedCash, hasNodes.cashButton);

            /**
             * オリジナルのボタンの活性状態を同期する。
             */
            copiedSyncToOrigin(hasNodes.creditButton, copiedCredit);
            copiedSyncToOrigin(hasNodes.cashButton, copiedCash);
        }
    };

    startObserveDomRendered();

</script>

<style>
  button.copiedPaymentButton.disabled {
    pointer-events: none;
    background-color: #ccc;
    color: #aaa;
  }

  div.bat-form-field.bat-form--cashondelivery-payment-submit {
    display: none;
  }

  a.bat-cta-style.button-secondary-dark.center {
    display: none;
  }

  a.bat-cta-style.button-secondary-dark.center.disabled {
    pointer-events: none;
    background: #dedede;
    cursor: not-allowed;
    opacity: 1;
    color: #aaa;
    display: none;
  }

  button.copiedPaymentButton.hidden {
    display: none;
  }

  button.copiedPaymentButton {
    background-color: #f5c342;
    border: 0;
    color: black;
    display: flex;

    justify-content: center;
    align-items: center;
    width: 100%;
    height: 45px;
    border-radius: 50px;
    font: inherit;
    font-weight: bold;
  }
</style>
